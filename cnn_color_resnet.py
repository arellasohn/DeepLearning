# -*- coding: utf-8 -*-
"""CNN_color_resnet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EGATG5cAxZlXyQnnqz62EE81bzAXppCy
"""

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Conv2D, MaxPooling2D, Flatten
from tensorflow.keras.datasets import cifar10
from tensorflow.keras.applications import ResNet50, VGG16
import numpy as np
import matplotlib.pyplot as plt

(X_train,y_train),(X_test,y_test) = cifar10.load_data()

print(X_train.shape, X_test.shape, y_train.shape, y_test.shape)

resnet_layer = ResNet50(weights='imagenet',include_top=False,input_shape=(32,32,3))
# weights='imagenet': imagenet을 통해 학습한 결과의 parameter를 사용하겠다는 의미
# include_top=False: 특징 추출 다음 단계(Dense layer)는 직접 학습하겠다는 의미
# input_shape=(32,32,3)
resnet_layer.trainable = False
# resnet_layer.trainable = True: resnet 구조만 가져오고 weights를 학습하겠다는 의미
# resnet_layer.trainable = False: 미리 학습된 resnet의 weight를 사용하겠다는 의미

CNN_model = Sequential([
    resnet_layer,
    # Flatten
    Flatten(),
    # Dense
    Dense(256,activation='relu'),
    Dense(10,activation='softmax')
])

CNN_model.summary()

CNN_model.compile(optimizer='adam',loss='sparse_categorical_crossentropy',metrics=['acc'])

ep = 20
batch = 512
val_ratio = 0.2

cifar10_result = CNN_model.fit(X_train, y_train,
                               epochs=ep,
                               batch_size=batch,
                               validation_split=val_ratio)

# test data 성능 확인
CNN_model.evaluate(X_test,y_test)

plt.plot(cifar10_result.history['loss'])
plt.plot(cifar10_result.history['val_loss'])

# X_test의 predict 후 예측 결과와 y_test 비교하기
# 서로 다르게 판단하 image의 index를 찾고
# 잘못 분류된 데이터 image와 예측 및 실제값 출력
pred_proba = CNN_model.predict(X_test)
pred = np.argmax(pred_proba,axis=1)

y_test.ravel()

# y_test는 2d array, pred는 1d array이므로
# y_test와 pred를 동일한 형태로 변경함
# y_test를 1d array로 변경
# ndarray.ravel(): 1d array로 변환
wrong_ind = np.argwhere(y_test.ravel() != pred)

wrong_ind

plt.imshow(X_test[3])
print(y_test[3])
print(pred[3])